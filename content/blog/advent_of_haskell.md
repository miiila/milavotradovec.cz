+++
title = "Advent of Haskell"
slug = "advent_of_haskell"
date = 2021-01-10
+++

I have a passion for puzzles. It's very well known by, well, anybody who spent more then 15 minutes with me. And I have a passion for programming as well. I wouldn't be doing that for a living otherwise. Couple of years ago, in 2017, I found out I can combine these two desires by participating in [Advent of Code](https://adventofcode.com/). It is an advent calendar for programmes - everyday, you get a puzzle, split into two parts and you should provide a solution. Language, technique, timeframe, everything is up to you. There is a global leaderboard, but it is designed for US try hards, because puzzles are released around 6am CET. I had a ton of fun doing 2017 in Python and I was very proud to finish it completely! In 2018, I used to live in London and I had decided to take the opportunity and learn myself a new language. I picked Rust and it was ok, but I gave up when I had to [fight Goblins](https://adventofcode.com/2018/day/15). I wanted to do better in 2019 and I wanted to try out functional programming. After a (too) short research, I choose Scala. And I failed terribly. I didn't like the language, I didn't like a concept of reusing the code from previous puzzles. Therefore, in 2020, I had two goals: finally finish or at least keep up until the last day and finally learn functional programming. Therefore, encouraged by [the article](https://honzajavorek.cz/blog/courting-haskell/), I choose Haskell. 

## Learn you an FP for a Great Good
[Haskell is a general-purpose, statically typed, purely functional programming language with type inference and lazy evaluation.](https://en.wikipedia.org/wiki/Haskell_%28programming_language%29) If you don't understand those fancy adjectives, I recommend checking linked Wikipedia article or Honza's post linked above. I would be just repeating what was said better there. I will rather focus on my own experience preparing ground for more stories about particular AoC days.

I have to admit I wasn't a complete FP newbie. During my university studies, I went trough Functional Programming course and I loved it. We used [Racket](https://racket-lang.org/) and everything was so... _logical_! I understood recursion, I understood different variable scopes, I understood what are side effects; all these things helped me to be a better software engineer. Which is a very nice thing to say, apart from the fact it would be great to apply all these learnings in a practice. Which I struggled with. FP struck back when I moved more towards system design and I finally saw amazing talk called [Boundaries](https://www.youtube.com/watch?v=eOYal8elnZk). The main message is a phrase "functional core - imperative shell", meaning you should aim for _pure_ functions without side effect as a main part of your system and push all _tainted_ functionality to the edge, where it cannot do any harm. My desire to be able to follow this rule was another reason, why I was so keen to invest into Haskell. Similarly to other people, my main resource was [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/). I went with online version and I have to confirm the book is really awesome. It is funny, readable, yet still highly educative. I spent roughly 2 weeks reading it up to chapter 13 and occasionally playing with some commands in interactive REPL.

## read $ Advent of Haskell !! 2
First thing I noticed was an ultimately crazy syntax. I really don't know what was the motivation and I still can't understand, why, for example, `!!` selects an item from list on specified index. Same goes for `/=` as not equals, weird list comprehensions and random usage of `|`. I got used to it, but even after 25 days, I was still looking up even the basic syntactic constructions like list comprehension or guards. And there goes the biggest disadvantage of `Learn you a Haskell` book - it doesn't have a (good) index. After a week, my head was full of "oh, it was on the page with the weird cowboy cartoon" memories, but looking the page up took me another ten minutes. When I built big enough muscle for remembering function name, the best help was (https://hackage.haskell.org/). Here I disagree with the missing documentation metioned in Honza's post above. I was able to find whatever I needed. I would love recommend more sources about Haskell for even greater good, but I haven't read any (yet). There is a good list in (again) Honza's post. I would like to find time for reading [What I Wish I Knew When Learning Haskell](http://dev.stephendiehl.com/hask/), but I will see.

 On the other hand, I heavily appreciate syntactic shortcuts removing unnecessary and confusing parentheses (looking your way, LISP) around expressions. For example: instead of writing `proofReadArticle(writeArticle adventOfHaskell)`, you can do `proofReadArticle $ writeArcticle adventOfHaskell`. `$` will just apply a function on its left side to the result of expression on its right side. Similarly, `<$>` is a map. It maps a function on left side to the list on the right side. The most advanced thing I understood was `<*>`. It is a little bit more complicated, but in general, it applies a list of functions to a list of suitable parameters. If I manage to write next batch of articles about solving particular puzzles, you will see it in action and understand it better, I promise.


## Naughty and Nice
If I can, I would immediately bring couple of features to more popular languages. Apart from `$` and `<$>` mentioned above, it would be [pattern matching](http://learnyouahaskell.com/syntax-in-functions#pattern-matching). It comes hand in hand with (strong) static typing, but it really helps to make your code more structured and easier to read. And it really helps with recursion. Another cool thing, I'd appreciate in my day to day job, arises from simple fact: functions are [curried](http://learnyouahaskell.com/higher-order-functions#curried-functions) by default. It means you don't have to call a function with all paramerets, you can provide just a subset of them. Rather then throwing and error, function will return new function expecting the rest of parameters. Only once you provide all of them, function is executed and you can get the final result.

I don't feel qualified to complaint about a language, which was designed by super smart people. But I would appreciate if I could be able to have a support for [polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)). Many times, I wanted to use multiple functions with the same name, but for different types or different amount of parameters. Another complain is about tuples. I abandoned tuples couple of times, because there is no easy way, how can you access nth item. I know it probably helps me with a design long-term, but for hacky puzzle solutions, it was a bummer. And I am still not sure how do I feel about [record syntax](http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax). It helps you with organisation of the code, but it complicates it in a same time. Because it creates functions named after "properties" of the record. Which means you can easily have a conflict and you could end up using bizarre variable names to overcome their usage in records.

## Was it worthy?
After doing all the puzzles (spolier, I really made them all, on time :-)), how do I feel about my little Haskell experiment? Well, first of all, I feel super proud I made it. It wasn't easy and I had very hard times remembering all my beloved Python or Rust for being way more user friendly. But no pain no gain - I consider my understanding of Functional Programming more settled. I am still at the beginning, because I barely touched monads or zippers or any other advance concepts. But the parts I used heavily ([functors](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux) - `<$>`, [applicative functors](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors) `<*>` symbol, [I/O monad](http://learnyouahaskell.com/input-and-output)) really gave me a better understanding what the FP hype is about. And it's about thinking globally. Or completely. Or just "fully". You do not apply a function just to some data and eventually skip other. You have either everything or nothing. You are thinking about your complete data, not just happy parts. You also learn how to write smaller functions, because bigger ones get out of control so fast you often delete them and rewrite them completely. And you become addicted to a [function composition](http://learnyouahaskell.com/higher-order-functions#composition), because it just feels so good. You have a function composed out of other functions, because all those functions are just transforming data. With a clear typed interface. 

I heavily recommend Haskell to everybody who is working on bigger systems. It will teach you better design, because there is no other way. I would really like to try writing some web application in Haskell. Using 3rd party libraries, writing tests and handling incoming opaque payloads. I would probably struggle a lot, but I would trust the result. Once it gets compiled, it will run.
